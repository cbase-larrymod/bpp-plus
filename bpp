#!/usr/bin/env ruby
# coding: utf-8

# BPP+ v1.0.4
#
# BPP+ is a BASIC v2 (Commodore 64) preprocessor designed for use with Petcat and tailored
# for the C*Base Larry Mod v3.1 - Build system. This updated version of the original
# symbolic preprocessor makes CBM BASIC programs easier to write and read.
#
# It supports cross-development of CBM BASIC programs by removing the need for line numbers
# and enabling the use of labels, scopes, and include directives.
#
# The preprocessed output can then be converted into a PRG file using the Petcat utility
# included with VICE.
#
# The original BPP repository can be found [here](https://github.com/hbekel/bpp).

require 'pathname'
require 'optparse'

# ---------------------------------------------------------------------------------------------
# Color Module
# ---------------------------------------------------------------------------------------------
module Color
  GREEN  = "\e[32m"
  CYAN   = "\e[36m"
  YELLOW = "\e[33m"
  GRAY   = "\e[90m"
  RESET  = "\e[0m"
end

# ---------------------------------------------------------------------------------------------
# Error Handling
# ---------------------------------------------------------------------------------------------

# Prints error message to stderr and exits with status 1
#
# @param line [Integer] Source line number where error occurred
# @param message [String] Error message to display
def error(line, message)
  STDERR.puts "error: line %d: %s" % [line, message]
  exit 1
end

# ---------------------------------------------------------------------------------------------
# String Extensions
# ---------------------------------------------------------------------------------------------

class String

  # BASIC keywords that cannot be used as label identifiers
  @@keywords = "end for next data input# input dim read let goto run if
                restore gosub return rem stop on wait load save verify def
                poke print# print cont list clr cmd sys open close get get# new
                tab( to fn spc( then not step + - * / ^ and or > = < sgn
                int abs usr fre pos sqr rnd log exp cos sin tan atn peek
                len str$ val asc chr$ left$ right$ mid$ ti$ ti st go ~".split(/\s+/)

  # Commodore 64 control characters and special sequences
  @@controls = ["\\$00", "\\$01", "\\$02", "\\$03", "\\$04",
    "\\$05", "\\$06", "\\$07", "\\$08", "\\$09", "\\$0a", "\\$0b",
    "\\$0c", "\\$0d", "\\$0e", "\\$0f", "\\$10", "\\$11", "\\$12",
    "\\$13", "\\$14", "\\$15", "\\$16", "\\$17", "\\$18", "\\$19",
    "\\$1a", "\\$1b", "\\$1c", "\\$1d", "\\$1e", "\\$1f", "\\$20",
    "\\$21", "\\$22", "\\$23", "\\$24", "\\$25", "\\$26", "\\$27",
    "\\$28", "\\$29", "\\$2a", "\\$2b", "\\$2c", "\\$2d", "\\$2e",
    "\\$2f", "\\$30", "\\$31", "\\$32", "\\$33", "\\$34", "\\$35",
    "\\$36", "\\$37", "\\$38", "\\$39", "\\$3a", "\\$3b", "\\$3c",
    "\\$3d", "\\$3e", "\\$3f", "\\$40", "\\$41", "\\$42", "\\$43",
    "\\$44", "\\$45", "\\$46", "\\$47", "\\$48", "\\$49", "\\$4a",
    "\\$4b", "\\$4c", "\\$4d", "\\$4e", "\\$4f", "\\$50", "\\$51",
    "\\$52", "\\$53", "\\$54", "\\$55", "\\$56", "\\$57", "\\$58",
    "\\$59", "\\$5a", "\\$5b", "\\$5c", "\\$5d", "\\$5e", "\\$5f",
    "\\$60", "\\$61", "\\$62", "\\$63", "\\$64", "\\$65", "\\$66",
    "\\$67", "\\$68", "\\$69", "\\$6a", "\\$6b", "\\$6c", "\\$6d",
    "\\$6e", "\\$6f", "\\$70", "\\$71", "\\$72", "\\$73", "\\$74",
    "\\$75", "\\$76", "\\$77", "\\$78", "\\$79", "\\$7a", "\\$7b",
    "\\$7c", "\\$7d", "\\$7e", "\\$7f", "\\$80", "\\$81", "\\$82",
    "\\$83", "\\$84", "\\$85", "\\$86", "\\$87", "\\$88", "\\$89",
    "\\$8a", "\\$8b", "\\$8c", "\\$8d", "\\$8e", "\\$8f", "\\$90",
    "\\$91", "\\$92", "\\$93", "\\$94", "\\$95", "\\$96", "\\$97",
    "\\$98", "\\$99", "\\$9a", "\\$9b", "\\$9c", "\\$9d", "\\$9e",
    "\\$9f", "\\$a0", "\\$a1", "\\$a2", "\\$a3", "\\$a4", "\\$a5",
    "\\$a6", "\\$a7", "\\$a8", "\\$a9", "\\$aa", "\\$ab", "\\$ac",
    "\\$ad", "\\$ae", "\\$af", "\\$b0", "\\$b1", "\\$b2", "\\$b3",
    "\\$b4", "\\$b5", "\\$b6", "\\$b7", "\\$b8", "\\$b9", "\\$ba",
    "\\$bb", "\\$bc", "\\$bd", "\\$be", "\\$bf", "\\$c0", "\\$c1",
    "\\$c2", "\\$c3", "\\$c4", "\\$c5", "\\$c6", "\\$c7", "\\$c8",
    "\\$c9", "\\$ca", "\\$cb", "\\$cc", "\\$cd", "\\$ce", "\\$cf",
    "\\$d0", "\\$d1", "\\$d2", "\\$d3", "\\$d4", "\\$d5", "\\$d6",
    "\\$d7", "\\$d8", "\\$d9", "\\$da", "\\$db", "\\$dc", "\\$dd",
    "\\$de", "\\$df", "\\$e0", "\\$e1", "\\$e2", "\\$e3", "\\$e4",
    "\\$e5", "\\$e6", "\\$e7", "\\$e8", "\\$e9", "\\$ea", "\\$eb",
    "\\$ec", "\\$ed", "\\$ee", "\\$ef", "\\$f0", "\\$f1", "\\$f2",
    "\\$f3", "\\$f4", "\\$f5", "\\$f6", "\\$f7", "\\$f8", "\\$f9",
    "\\$fa", "\\$fb", "\\$fc", "\\$fd", "\\$fe", "\\$ff", "CTRL\\-A",
    "CTRL\\-B", "CTRL\\-C", "CTRL\\-D", "CTRL\\-E", "CTRL\\-F",
    "CTRL\\-G", "CTRL\\-H", "CTRL\\-I", "CTRL\\-J", "CTRL\\-K",
    "CTRL\\-L", "CTRL\\-M", "CTRL\\-N", "CTRL\\-O", "CTRL\\-P",
    "CTRL\\-Q", "CTRL\\-R", "CTRL\\-S", "CTRL\\-T", "CTRL\\-U",
    "CTRL\\-V", "CTRL\\-W", "CTRL\\-X", "CTRL\\-Y", "CTRL\\-Z",
    "CTRL\\-3", "CTRL\\-6", "CTRL\\-7", "SHIFT\\-SPACE", "CBM\\-K",
    "CBM\\-I", "CBM\\-T", "CBM\\-@", "CBM\\-G", "CBM\\-\\+",
    "CBM\\-M", "CBM\\-POUND", "SHIFT\\-POUND", "CBM\\-N", "CBM\\-Q",
    "CBM\\-D", "CBM\\-Z", "CBM\\-S", "CBM\\-P", "CBM\\-A", "CBM\\-E",
    "CBM\\-R", "CBM\\-W", "CBM\\-H", "CBM\\-J", "CBM\\-L", "CBM\\-Y",
    "CBM\\-U", "CBM\\-O", "SHIFT\\-@", "CBM\\-F", "CBM\\-C",
    "CBM\\-X", "CBM\\-V", "CBM\\-B", "SHIFT\\-\\*", "SHIFT\\-A",
    "SHIFT\\-B", "SHIFT\\-C", "SHIFT\\-D", "SHIFT\\-E", "SHIFT\\-F",
    "SHIFT\\-G", "SHIFT\\-H", "SHIFT\\-I", "SHIFT\\-J", "SHIFT\\-K",
    "SHIFT\\-L", "SHIFT\\-M", "SHIFT\\-N", "SHIFT\\-O", "SHIFT\\-P",
    "SHIFT\\-Q", "SHIFT\\-R", "SHIFT\\-S", "SHIFT\\-T", "SHIFT\\-U",
    "SHIFT\\-V", "SHIFT\\-W", "SHIFT\\-X", "SHIFT\\-Y", "SHIFT\\-Z",
    "SHIFT\\-\\+", "CBM\\-\\-", "SHIFT\\-\\-", "SHIFT\\-\\^",
    "CBM\\-\\*", "CBM\\-\\^", "CTRL\\-A", "CTRL\\-B", "stop",
    "CTRL\\-D", "wht", "CTRL\\-F", "CTRL\\-G", "dish", "ensh",
    "\\\\n", "CTRL\\-K", "CTRL\\-L", "\\\\n", "swlc", "CTRL\\-O",
    "CTRL\\-P", "down", "rvon", "home", "del", "CTRL\\-U", "CTRL\\-V",
    "CTRL\\-W", "CTRL\\-X", "CTRL\\-Y", "CTRL\\-Z", "esc", "red",
    "rght", "grn", "blu", "WHT", "up/lo\\ lock\\ on", "up/lo\\ lock\\
    off", "return", "lower\\ case", "DOWN", "RVS\\ ON", "HOME",
    "delete", "esc", "RED", "RIGHT", "GRN", "BLU", "REVERSE\\ ON",
    "white", "down", "reverse\\ on", "home", "red", "right", "green",
    "blue", "WHITE", "RETURN", "DOWN", "RVSON", "HOME", "DEL", "RED",
    "RIGHT", "GREEN", "BLUE", "space", "SPACE", "orng", "f1", "f3",
    "f5", "f7", "f2", "f4", "f6", "f8", "sret", "swuc", "blk", "up",
    "rvof", "clr", "inst", "brn", "lred", "gry1", "gry2", "lgrn",
    "lblu", "gry3", "pur", "left", "yel", "cyn", "orange", "F1", "F3",
    "F5", "F7", "F2", "F4", "F6", "F8", "shift\\ return", "upper\\
    case", "BLK", "UP", "RVS\\ OFF", "CLR", "insert", "BROWN",
    "LT\\.RED", "GRAY1", "GRAY2", "lt\\ green", "LT\\.BLUE", "GRAY3",
    "PUR", "LEFT", "YEL", "cyn", "orange", "f1", "f3", "r5", "f7",
    "f2", "f4", "f6", "f8", "black", "up", "reverse\\ off", "clear",
    "brown", "pink", "dark\\ gray", "gray", "light\\ green", "light\\
    blue", "light\\ gray", "purple", "left", "yellow", "cyan",
    "ORANGE", "F1", "F3", "F5", "F7", "F2", "F4", "F6", "F8", "BLACK",
    "UP", "RVSOFF", "CLR", "INST", "BROWN", "LIG\\.RED", "GRAY\\ 1",
    "GREY\\ 2", "LIG\\.GREEN", "LIG\\.BLUE", "GREY\\ 3", "PURPLE",
    "LEFT", "YELLOW", "CYAN"]

  # Custom build controls
  @@buildControls = ["buildstamp"]

  # Generates regex pattern for control sequences
  #
  # @param open [String] Opening delimiter
  # @param close [String] Closing delimiter
  # @return [Regexp] Pattern matching control sequences
  def self.controls(open, close)
    combinedControls = @@controls + @@buildControls
    /#{Regexp.quote(open)}((\d+\s+)?(#{combinedControls.join('|')}))#{Regexp.quote(close)}/i
  end

  # Regex patterns for escaped and unescaped control sequences
  @@unescaped = self.controls('{', '}')
  @@escaped = self.controls('~', '~')

  # Checks if string is a valid label identifier
  # Must not be a BASIC keyword
  #
  # @return [Boolean] true if valid label, false otherwise
  def label?
    !keyword?
  end

  # Checks if string is a BASIC keyword
  #
  # @return [Boolean] true if keyword, false otherwise
  def keyword?
    @@keywords.include?(self)
  end

  # Checks if string contains hyphens
  #
  # @return [Boolean] true if contains hyphen, false otherwise
  def has_hyphen?
    self.include?('-')
  end

  # Escapes control sequences by wrapping in ~ delimiters
  def escape!
    gsub! @@unescaped, "~\\1~"
  end

  # Unescapes control sequences by wrapping in { delimiters
  def unescape!
    gsub! @@escaped, "{\\1}"
  end
end

# ---------------------------------------------------------------------------------------------
# IO Extensions
# ---------------------------------------------------------------------------------------------

class IO
  # Yields each line with its line number
  #
  # @yield [String, Integer] line content and line number
  def each_line_with_number(&block)
    number = 0
    each_line do |line|
      yield line, number+=1
    end
  end
end

# ---------------------------------------------------------------------------------------------
# Node Module - Tree Structure Support
# ---------------------------------------------------------------------------------------------

module Node
  include Enumerable

  attr_writer :parent

  # Checks if node is root (has no parent)
  #
  # @return [Boolean] true if root node
  def root?
    parent.nil?
  end

  # Checks if node is leaf (has no children)
  #
  # @return [Boolean] true if leaf node
  def leaf?
    children.count == 0
  end

  # Gets parent node
  #
  # @return [Node, nil] parent node or nil if root
  def parent
    @parent ||= nil
  end

  # Gets child nodes
  #
  # @return [Array] array of child nodes
  def children
    @children ||= []
  end

  # Adds child node(s) to this node
  #
  # @param child [Node, Array<Node>] child node(s) to add
  def addChild(child)
    @children ||= []
    child = [child].flatten

    @children += child
    child.each { |c| c.parent = self }
  end

  # Removes child node from this node
  #
  # @param child [Node] child node to remove
  # @return [Node, nil] removed child or nil if not found
  def removeChild(child)
    if children.include? child
      children.delete(child)
      child.parent = nil
      child
    end
  end

  # Adds child using << operator
  #
  # @param child [Node] child node to add
  # @return [Node] the added child
  def <<(child)
    addChild(child)
    child
  end

  # Gets next sibling of specified class
  #
  # @param clazz [Class] class to match (default: Node)
  # @return [Node, nil] next sibling or nil if none found
  def next_sibling(clazz=Node)
    node = nil

    after = false
    return node if root?

    parent.each do |sibling|
      if sibling == self
        after = true
        next
      end

      if after && sibling.is_a?(clazz)
        node = sibling
        break
      end
    end

    return node
  end

  # Checks if next sibling exists
  #
  # @param clazz [Class] class to match (default: Node)
  # @return [Boolean] true if next sibling exists
  def next_sibling?(clazz=Node)
    not next_sibling(clazz).nil?
  end

  # Iterates through children and grandchildren of specified class
  #
  # @param clazz [Class] class to match (default: Node)
  # @yield [Node] each matching node
  def each(clazz=Node, &block)
    children.each do |child|
      yield child if child.is_a? clazz
      child.each do |grandchild|
        yield grandchild if grandchild.is_a? clazz
      end
    end
  end
end

# ---------------------------------------------------------------------------------------------
# Label - Represents a label definition
# ---------------------------------------------------------------------------------------------

class Label
  include Node

  attr_reader :name, :source

  # Creates a new label
  #
  # @param name [String] label name
  # @param source [Integer] source line number
  def initialize(name, source=0)
    @name = name
    @source = source
  end

  # Validates that label doesn't contain hyphens
  # Raises error if hyphens are found in label name or full path
  def validate_no_hyphens!
    # Check the label name itself
    if @name.has_hyphen?
      error(@source, "hyphens not allowed in labels: '#{@name}'")
    end
    
    # Check the full path (handles nested labels like label-1.label-2)
    full_path = path
    if full_path.has_hyphen?
      error(@source, "hyphens not allowed in labels: '#{full_path}'")
    end
  end

  # Gets full path to this label from root or specified scope
  #
  # @param scope [Node] scope to calculate path from (default: parent)
  # @return [String] dot-separated path to label
  def path(scope=parent)
    p = parent
    n = name

    until p.nil? || p == scope
      n = "%s.%s" % [p.name, n]
      p = p.parent
    end
    return n
  end

  # @return [String] label name
  def to_s
    @name
  end
end

# ---------------------------------------------------------------------------------------------
# Code - Represents BASIC code
# ---------------------------------------------------------------------------------------------

class Code < String
  include Node

  # @return [String] code with whitespace removed
  def to_s
    gsub(/\s+/, "")
  end
end

# ---------------------------------------------------------------------------------------------
# Literal - Represents a string literal
# ---------------------------------------------------------------------------------------------

class Literal < String
  include Node

  # @return [String] quoted string literal
  def to_s
    '"%s"' % [self]
  end
end

# ---------------------------------------------------------------------------------------------
# Reference - Represents a label reference
# ---------------------------------------------------------------------------------------------

class Reference
  include Node

  attr_reader :name

  # Creates a new label reference
  #
  # @param name [String] referenced label name
  def initialize(name)
    @name = name
  end
end

# ---------------------------------------------------------------------------------------------
# Line - Represents a line of BASIC code
# ---------------------------------------------------------------------------------------------

class Line
  include Node

  attr_accessor :source, :file

  # Line number counter (starts at 0, increments to 1 for first line)
  @@number = 0

  attr_reader :number, :text

  # Creates a new BASIC line
  #
  # @param text [String] line text
  # @param source [Integer] source line number
  # @param file [String] source filename
  def initialize(text, source=0, file="stdin")
    @text = text
    @file = file
    @source = source
    parse
    cleanup
  end

  # Sets parent and assigns line number
  #
  # @param node [Node] parent node
  def parent=(node)
    super(node)
    @number = @@number+=1
  end

  # Parses line text into Code, Literal, and Reference nodes
  def parse
    @text.unescape!

    until @text.empty?

      # String literal - allow empty quoted strings
      if (match = /^["](?<string>[^"]*)["]/.match(@text))
        self << Literal.new(match["string"])
        @text = match.post_match.strip

      # GOTO/GOSUB with label references
      # Note: Fixed regex to prevent bare THEN in IF...THEN from being misparsed
      elsif (match = /^(?<code>go(sub|to))\s*(?<labels>[\w\s,.]+)/
        .match(@text))

        self << Code.new(match["code"])
        labels = match["labels"].split(/\s*,/)

        labels.each do |l|
          l.strip!
          if l.keyword?
            self << Code.new(l)
            next
          end
          self << Reference.new(l)
          self << Code.new(",") unless l == labels.last
        end
        @text = match.post_match.strip

      # Statement separator - handle single colon only (fixes :: problem)
      elsif (match = /^(?<separator>:)/.match(@text))
        self << Code.new(":")
        @text = match.post_match.strip

      # Regular code (not string or colon)
      elsif (match = /^(?<code>[^":]+?(?!then|go(to|sub)))/.match(@text))
        break if match["code"] =~ /\s*rem\s*/

        self << Code.new(match["code"])
        @text = match.post_match.strip
      end
    end
  end

  # Removes trailing colon if present
  def cleanup
    last = children.last
    return unless last.is_a? Code

    children.pop if last == ":"
  end

  # Converts line to BASIC format with line number
  #
  # @return [String] formatted BASIC line
  def to_s
    s = "%d " % [number]

    children.each do |child|
      if child.is_a? Reference
        begin
          s += parent.resolve(child).to_s
        rescue => e
          error(number, "could not resolve label '#{child.name}'")
        end
      else
        s += child.to_s
      end
    end
    return s
  end
end

# ---------------------------------------------------------------------------------------------
# Scope - Represents a code scope
# ---------------------------------------------------------------------------------------------

class Scope 
  include Node

  attr_reader :name

  # Creates a new scope
  #
  # @param name [String, nil] scope name
  def initialize(name=nil)
    @name = name.to_s
  end

  # Checks if label is defined in this scope
  #
  # @param label [Label] label to check
  # @return [Boolean] true if label is defined
  def defined?(label)
    children.each do |child|
      next unless child.is_a? Label
      return true if child.name.downcase == label.name.downcase
    end
    false
  end

  # Gets full path to this scope
  #
  # @return [String] dot-separated path
  def path
    n = name
    p = parent

    until(p.root?)
      n = "%s.%s" % [p.name, n]
      p = p.parent
    end

    return n
  end

  # Resolves label reference to line number
  #
  # @param reference [Reference] label reference to resolve
  # @return [Integer] line number
  # @raise [RuntimeError] if label cannot be resolved
  def resolve(reference)

    children.each do |label|
      next unless label.is_a? Label

      if label.name.downcase == reference.name.downcase || label.path(parent).downcase == reference.name.downcase

        if label.next_sibling?(Line)
          return label.next_sibling(Line).number
        else
          error(label.source, "referenced label '%s' not followed by basic code" % [label])
        end
      end
    end

    each(Scope) do |scope|
      scope.each(Label) do |label|
        if label.path(self).downcase == reference.name.downcase || label.path(parent).downcase == reference.name.downcase

          if label.next_sibling?(Line)
            return label.next_sibling(Line).number
          else
            error(label.source, "referenced label '%s' not followed by basic code" % [label])
          end
        end
      end
    end

    return parent.resolve(reference)
  end

  # @return [String] scope description
  def to_s
    return "global scope" if root?
    return "scope '#{path}'"
  end
end

# ---------------------------------------------------------------------------------------------
# Parser - Parses BPP source files
# ---------------------------------------------------------------------------------------------

class Parser
  # Parses a file by path
  #
  # @param path [String, Pathname] file path
  # @param scope [Scope] parent scope
  # @return [Scope] parsed scope tree
  def self.parse_file(path, scope = Scope.new)
    pathname = Pathname.new(path).expand_path
    
    unless pathname.exist?
      error(0, "file not found: '#{pathname}'")
    end

    unless pathname.file?
      error(0, "not a file: '#{pathname}'")
    end

    File.open(pathname, "r") do |io|
      Parser.new(io, pathname, scope).parse
    end
  end

  # Creates a new parser
  #
  # @param io [IO] input stream
  # @param file [String, Pathname] source filename
  # @param scope [Scope] parent scope
  def initialize(io = STDIN, file = Pathname.new("stdin"), scope = Scope.new)
    @io = io
    @file = Pathname.new(file).expand_path
    @scope = scope
  end

  # Includes external file (source or data)
  #
  # @param type [String] include type ("source" or "data")
  # @param path [String] file path
  # @param source [Integer] source line number for error reporting
  def include(type, path, source)
    pathname = Pathname.new(path)

    # Resolve relative paths relative to the including file
    unless pathname.absolute?
      if @file && @file.to_s != "stdin"
        pathname = @file.dirname.join(path)
      end
    end

    pathname = pathname.expand_path

    unless pathname.exist?
      error(source, "include: file not found: '#{path}'")
    end

    case type
    when "source"
      include_source(pathname)
    when "data"
      include_data(pathname)
    else
      error(source, "include: unknown type: '#{type}'")
    end
  end

  # Includes source file
  #
  # @param pathname [Pathname] file path
  def include_source(pathname)
    Parser.parse_file(pathname, @scope)
  end

  # Includes binary data file as DATA statements
  #
  # @param pathname [Pathname] file path
  def include_data(pathname)
    unless pathname.exist?
      error(0, "data file not found: '#{pathname}'")
    end

    input = pathname.open("rb")
    i = 0
    line = "data "

    input.each_byte do |byte|
      line += "%d," % [byte]

      if i > 0 && i % 16 == 0
        @scope << Line.new(line.chop) unless line.empty?
        line = "data "
      end

      i += 1
    end

    @scope << Line.new(line.chop) unless line == "data "
    input.close
  end

  # Parses input stream
  #
  # @return [Scope] parsed scope tree
  def parse
    buffer = ""

    @io.each_line_with_number do |line, source|
      line.chomp!
      line.strip!
      line.escape!

      # Support line continuation using backslash (\)
      #
      # Lets you split a long BASIC line over several lines in the source.
      # The preprocessor joins them with ":" (BASIC's statement separator).
      #
      # Example:
      #   poke 53281,0\
      #   poke 53280,0\
      #   g$=chr$(13)
      #
      # Becomes:
      #   poke 53281,0:poke 53280,0:g$=chr$(13)

      if line.end_with?("\\")
        buffer << line.chomp("\\").rstrip + ":"
        next
      else
        line = buffer + line
        buffer = "" # Reset buffer for next group
      end

      next if line.empty?
      # Skip regular REM comments but preserve special Blitz directives (rem ** ...)
      next if line =~ /^rem(?!\s*\*\*)/i
      next if line =~ /^;/

      # Handle !include directive
      if line =~ /^!include\s+(.+?)\s+"(.+?)"/
        match = $&
        include($1, $2, source)
        line.sub!(match, '')
        redo

      # Handle !blitz directive - converts to rem ** format
      elsif line =~ /^!blitz\s+(.+)/
      blitz_cmd = $1
      @scope << Line.new("rem ** #{blitz_cmd}", source, @file)
      line.sub!(/^!blitz\s+.+/, '')
      redo

      # Label definition matching
      # 
      # Labels must appear at the start of a line and are followed by a colon.
      # The ^ anchor ensures we only match at line start (or after previous label removal).
      #
      # Strategy: Capture identifiers that could be labels (valid or invalid)
      # Pattern: [a-zA-Z_0-9][\w$£@#%&!*+<>?/-]*
      # - Starts with letter, underscore, or digit (we'll validate the start separately)
      # - Can contain word chars plus common special chars someone might use
      # - Excludes: = ( ) [ ] { } " ' , ; (space) which indicate BASIC code
      #
      # The key insight: At the start of a line, if we see identifier-like chars followed by :,
      # it's likely meant to be a label. We capture it and validate it.
      #
      # Guard: !match[1].keyword? - Don't treat BASIC keywords as labels
      #
      elsif (match = line.match(/^([\w$£@#%&!*+<>?\/-]+):/)) && (!match[1].keyword?)
        label_name = match[1]
        
        # Safety check
        if label_name.nil? || label_name.empty?
          error(source, "invalid label syntax")
        end
        
        # Validate: Cannot start with a number
        if label_name =~ /^[0-9]/
          error(source, "label cannot start with a number: '#{label_name}'")
        end
        
        # Validate: Cannot start with a special character (must start with letter or underscore)
        if label_name =~ /^[^a-zA-Z_]/
          error(source, "label must start with a letter or underscore: '#{label_name}'")
        end
        
        # Validate: Cannot contain hyphens
        if label_name =~ /-/
          error(source, "hyphens not allowed in labels: '#{label_name}'")
        end
        
        # Validate: Can only contain letters, digits, underscores (check for any other chars)
        if label_name =~ /[^\w]/
          error(source, "special characters not allowed in labels: '#{label_name}'")
        end
        
        label = Label.new(label_name, source)

        if @scope.defined?(label)
          error(source, "label '%s' already defined in %s" % [label, @scope])
        end

        @scope << label
        line.sub!(/^([\w$@#%&!*+<>?\/-]+):/, '')
        redo

      elsif line =~ /^{/
        @scope = @scope << Scope.new(@scope.children.last)
        line.sub!(/^{/, '')
        redo

      elsif line =~ /^([^}]+)/
        @scope << Line.new($1, source, @file)
        line.sub!($1, '')
        redo

      elsif line =~ /}$/
        if @scope.root?
          error(source, "unexpected '}' - no scope to close")
        end
        @scope = @scope.parent
        line.sub!(/}$/, '')
        redo
      end
    end

    @io.close unless @io == STDIN
    @scope
  end
end

# ---------------------------------------------------------------------------------------------
# Preprocessor - Main preprocessor class
# ---------------------------------------------------------------------------------------------

class Preprocessor
  # Creates a new preprocessor
  #
  # @param input [IO, nil] input stream (nil for file-based input)
  # @param filename [String] source filename
  # @param output [IO] output stream
  def initialize(input=STDIN, filename="stdin", output=STDOUT)
    @input = input
    @filename = filename
    @output = output
  end

  # Processes input and builds syntax tree
  def process()
    if @filename == "stdin"
      @tree = Parser.new(@input, @filename, Scope.new("global")).parse
    else
      @tree = Parser.parse_file(@filename, Scope.new("global"))
    end
  rescue Errno::ENOENT => e
    error(0, "file not found: #{e.message}")
  rescue Errno::EACCES => e
    error(0, "permission denied: #{e.message}")
  rescue StandardError => e
    STDERR.puts "unexpected error: #{e.message}"
    STDERR.puts e.backtrace.join("\n")
    exit 1
  end

  # Looks up source location for a BASIC line number
  #
  # @param num [Integer] BASIC line number
  def lookup(num)
    @tree.each(Line) do |line|
      if line.number == num
        puts "BASIC line #{num} corresponds to:"
        puts "  Source file: #{line.file}"
        puts "  Source line: #{line.source}"
        return
      end
    end
    puts "BASIC line #{num} not found in compiled output"
  end

  # Outputs processed BASIC code
  def put()
    @tree.each(Line) { |line| puts line }
  end
end

# ---------------------------------------------------------------------------------------------
# Main Entry Point
# ---------------------------------------------------------------------------------------------

if __FILE__ == $PROGRAM_NAME
  options = {}
  
  OptionParser.new do |opts|
    opts.on("-l", "--line LINE", Integer, "Lookup source location for BASIC line number") do |l|
      options[:line] = l
    end

    opts.on("-h", "--help", "Show this help message") do
      puts ""
      puts "    #{Color::GREEN}Usage:#{Color::RESET} bpp [options] [file.bpp]"
      puts "           or cat file.bpp | bpp [options]"
      puts ""
      puts "    #{Color::CYAN}Description:#{Color::RESET}"
      puts "      A Commodore 64 BASIC v2 preprocessor for use with Petcat. Translates"
      puts "      labeled BASIC source into numbered line format for compilation and"
      puts "      execution."
      puts ""
      puts "      See README.md for details on BPP+ functions and features"
      puts "      specifically tailored for C*Base Larry Mod v3.1"
      puts ""
      puts "    #{Color::CYAN}Options:#{Color::RESET}"
      puts "      -l, #{Color::GRAY}--line LINE#{Color::RESET}    Lookup source file location for a BASIC line number."
      puts "                         Use this when debugging: if your program crashes with"
      puts "                         'ERROR IN 47', run 'bpp -l 47 file.bpp' to find which"
      puts "                         line in your source .bpp file corresponds to line 47"
      puts "                         in the compiled output."
      puts ""
      puts "      -h, #{Color::GRAY}--help#{Color::RESET}         Show this help message"
      puts "      -v, #{Color::GRAY}--version#{Color::RESET}      Show version information"
      puts ""
      puts "    #{Color::CYAN}Examples:#{Color::RESET}"
      puts "      bpp input.bpp                        #{Color::GRAY}# Process file to stdout#{Color::RESET}"
      puts "      bpp input.bpp > output.bas           #{Color::GRAY}# Save to file#{Color::RESET}"
      puts "      bpp input.bpp | sed 's/x/y/' > out   #{Color::GRAY}# Pipe through other tools#{Color::RESET}"
      puts ""
      puts "    #{Color::CYAN}Debugging:#{Color::RESET}"
      puts "      bpp -l 47 input.bpp                  #{Color::GRAY}# Output: output.bpp, line 23#{Color::RESET}"
      puts ""
      exit
    end

    opts.on("-v", "--version", "Show version") do
      puts ""
      puts "    #{Color::CYAN}BPP+#{Color::RESET} v1.0.4"
      puts "    #{Color::GRAY}A Commodore 64 BASIC v2 preprocessor for use with Petcat#{Color::RESET}"
      puts ""
      puts "    #{Color::CYAN}This version is based on:#{Color::RESET}"
      puts "      bpp basic preprocessor"
      puts "      Copyright (c) 2015, Henning Bekel <h.bekel@googlemail.com>"
      puts "      All rights reserved."
      puts ""
      exit
    end
  end.parse!

  filename = ARGV.shift

  # Show brief usage if no input provided (not reading from pipe)
  if filename.nil? && STDIN.tty?
    puts ""
    puts "    #{Color::GREEN}Usage:#{Color::RESET} bpp [options] [file.bpp]"
    puts "           or cat file.bpp | bpp [options]"
    puts ""
    puts "    #{Color::GRAY}Try 'bpp -h or --help' for more information."
    puts ""
    exit 0
  end

  begin
    pp = if filename
           Preprocessor.new(nil, filename)
         else
           Preprocessor.new
         end

    pp.process

    if options.key?(:line)
      pp.lookup(options[:line])
    else
      pp.put
    end
  rescue Interrupt
    STDERR.puts "\nInterrupted"
    exit 130
  end
end